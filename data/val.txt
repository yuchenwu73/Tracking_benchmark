# 无人机多目标跟踪系统

## 项目简介

本项目是一个专门针对8K高分辨率视频中无人机目标的多目标检测与跟踪系统。系统基于YOLO11目标检测模型和先进的多目标跟踪算法（ByteTrack和BoT-SORT），能够在高分辨率视频中准确检测和跟踪小型无人机目标。

## 主要特性

- 🎯 **高精度检测**: 基于YOLO11模型的无人机目标检测
- 🔄 **多目标跟踪**: 支持ByteTrack和BoT-SORT两种先进跟踪算法
- 📹 **8K视频支持**: 专门优化处理8K高分辨率视频
- ⚡ **高效处理**: 采用子图切分策略提高处理效率
- 📊 **性能监控**: 实时显示各模块处理时间和性能统计
- 🎨 **可视化跟踪**: 实时显示检测框、跟踪轨迹和目标ID
- 🧵 **多线程支持**: 提供多线程版本提高处理效率
- 🖥️ **GUI界面**: 支持图形界面操作

## 跟踪结果说明

### 🔢 数字含义解释
在跟踪视频中显示的数字有以下含义：

1. **黄色大数字（1、2、8等）**:
   - 这是**目标跟踪ID**，每个无人机被分配一个唯一的身份标识号
   - 系统自动为每个新检测到的目标分配递增的ID号
   - 即使目标暂时消失，重新出现时会保持相同ID（如果算法判断是同一目标）

2. **蓝色标签（如"drone 0.91"）**:
   - "drone": 目标类别名称
   - "0.91": 检测置信度分数（0-1之间，越接近1表示检测越可靠）

3. **绿色轨迹线**: 显示每个目标的历史运动轨迹

4. **彩色检测框**: 围绕目标的边界框，不同颜色区分不同目标

## 系统架构

```
benchmark/
├── README_zh_CN.md                    # 中文说明文档
├── requirements.txt                   # 完整依赖列表
├── requirements-minimal.txt           # 最小依赖列表
├── file_rename_plan.md               # 重命名计划文档
├── RENAME_SUMMARY.md                 # 重命名操作总结
├── last.pt                           # 训练好的YOLO模型
├── uav_tracking_main.py              # 主要跟踪脚本
├── uav_tracking_threaded.py          # 多线程版本
├── model_validation.py               # 模型验证脚本
├── data/                             # 数据和配置
│   ├── simple_tracking_demo.py       # 简化演示
│   ├── update_dataset_paths.py       # 路径更新工具
│   ├── bytetrack.yaml               # ByteTrack配置
│   ├── botsort.yaml                 # BoT-SORT配置
│   ├── uav.yaml                     # 数据集配置
│   ├── classes.txt                  # 类别标签
│   ├── train.txt                    # 训练集列表
│   ├── val.txt                      # 验证集列表
│   ├── images/                      # 图像数据
│   └── labels/                      # 标注数据
└── tracker/                         # 跟踪算法
    ├── bytetrack_tracker.py         # ByteTrack算法
    ├── botsort_tracker.py           # BoT-SORT算法
    ├── base_tracker.py              # 基础跟踪器
    ├── lightweight_tracker.py       # 轻量级跟踪器
    └── utils/                       # 工具函数
        ├── global_motion_compensation.py  # 全局运动补偿
        ├── detection_matching.py    # 检测匹配
        └── kalman_filter.py         # 卡尔曼滤波器
```

## 算法原理

### ByteTrack算法
- **核心思想**: 利用低置信度检测框进行数据关联，减少目标丢失
- **关键特性**: 两阶段关联策略，先高置信度后低置信度
- **适用场景**: 目标密集、遮挡频繁的场景

### BoT-SORT算法
- **核心思想**: 结合运动模型和外观特征的多目标跟踪
- **关键特性**: 全局运动补偿(GMC) + 卡尔曼滤波 + ReID特征
- **适用场景**: 相机运动较大、需要长期跟踪的场景
## 环境要求

### 系统要求
- Python 3.8+
- CUDA 11.0+ (推荐使用GPU加速)
- 8GB+ GPU显存 (处理8K视频)

### 依赖包
所有依赖包已在 `requirements.txt` 中定义，包括：
- **深度学习框架**: torch, torchvision, ultralytics
- **计算机视觉**: opencv-python, opencv-contrib-python
- **科学计算**: numpy, scipy, matplotlib
- **跟踪算法**: lap (线性分配算法)
- **工具库**: tqdm, PyYAML

## 安装指南

1. **克隆项目**
```bash
git clone <repository-url>
cd benchmark
```

2. **安装依赖**

**完整安装（推荐）**：
```bash
pip install -r requirements.txt
```

**最小安装（仅核心依赖）**：
```bash
pip install -r requirements-minimal.txt
```

**GPU版本安装**：
```bash
# 对于CUDA 12.1
pip install torch==2.2.2 torchvision==0.17.2 torchaudio==2.2.2 --index-url https://download.pytorch.org/whl/cu121
pip install -r requirements-minimal.txt
```

3. **验证安装**
```bash
python -c 'import torch, cv2, ultralytics; print("所有依赖安装成功!")'
python -c "import torch; print(f'CUDA可用: {torch.cuda.is_available()}')"
```

4. **准备模型文件**
确保项目根目录下有训练好的模型文件 `last.pt`

## 快速开始

### 第一次运行
1. **检查环境**
```bash
python -c "import torch; print(f'PyTorch版本: {torch.__version__}')"
python -c "import cv2; print(f'OpenCV版本: {cv2.__version__}')"
```

2. **运行简单演示**
```bash
# 首先运行简化版本测试
python data/simple_tracking_demo.py
```

3. **运行完整版本**
```bash
# 修改视频路径后运行主脚本
python uav_tracking_main.py
```

**注意**: 运行前请确保修改脚本中的视频路径为您的实际视频文件路径。

### 性能对比测试
```bash
# 标准版本
python uav_tracking_main.py

# 多线程版本（推荐用于大文件）
python uav_tracking_threaded.py
```

## 使用方法

### 1. 主要多目标跟踪

**脚本**: `uav_tracking_main.py`

```bash
python uav_tracking_main.py
```

**功能特点**:
- 支持8K视频处理
- 自动子图切分 (960x1080)
- 实时性能监控
- 轨迹可视化
- 详细的时间统计

**配置修改**:
```python
# 修改视频路径
video_path = "your_video_path.MOV"

# 选择跟踪器
tracker = initialize_tracker("data/bytetrack.yaml")  # ByteTrack
# tracker = initialize_tracker("data/botsort.yaml")   # BoT-SORT
```

### 2. 高性能多线程版本

**脚本**: `uav_tracking_threaded.py`

```bash
python uav_tracking_threaded.py
```

**优势**:
- 异步帧读取，减少I/O等待
- 队列缓冲机制 (maxsize=10)
- 适合处理大型8K视频文件
- 更高的处理吞吐量

### 3. 简化版演示

**脚本**: `data/simple_tracking_demo.py`

```bash
python data/simple_tracking_demo.py
```

适用于快速测试和原型验证，代码简洁易懂。

### 4. 模型验证和评估

**脚本**: `model_validation.py`

```bash
python model_validation.py
```

用于验证模型在验证集上的性能，支持CPU和GPU评估。

### 5. 数据集路径更新

**脚本**: `data/update_dataset_paths.py`

```bash
python data/update_dataset_paths.py
```

用于更新数据集中的文件路径，支持中文路径。

## 视频路径配置

在运行脚本前，需要修改视频路径：

### 主要脚本中的路径配置
```python
# uav_tracking_main.py 第72行
video_path = "D:/项目/基于8k的弱小多目标跟踪/无人机/无人机/0.MOV"

# uav_tracking_threaded.py 第74行
video_path = "D:/项目/基于8k的弱小多目标跟踪/无人机/无人机/1.MOV"

# data/simple_tracking_demo.py 第10行
video_path = "D:/项目/基于8k的弱小多目标跟踪/无人机/无人机/1.MOV"
```

**请将这些路径修改为您的实际视频文件路径。**

## 配置说明

### 跟踪器配置

#### ByteTrack配置 (`data/bytetrack.yaml`)
```yaml
tracker_type: bytetrack
track_high_thresh: 0.25    # 第一次关联阈值
track_low_thresh: 0.1      # 第二次关联阈值
new_track_thresh: 0.25     # 新轨迹初始化阈值
track_buffer: 30           # 轨迹缓冲帧数
match_thresh: 0.8          # 匹配阈值
fuse_score: True           # 是否融合置信度分数
```

#### BoT-SORT配置 (`data/botsort.yaml`)
```yaml
tracker_type: botsort
track_high_thresh: 0.25
track_low_thresh: 0.1
new_track_thresh: 0.25
track_buffer: 30
match_thresh: 0.8
fuse_score: True
gmc_method: sparseOptFlow  # 全局运动补偿方法
proximity_thresh: 0.5      # 空间邻近阈值
appearance_thresh: 0.25    # 外观相似度阈值
with_reid: False           # 是否启用ReID
```

### 数据集配置 (`data/uav.yaml`)
```yaml
path: D:/项目/基于8k的弱小多目标跟踪/benchmark/data
train: train.txt
val: val.txt
names:
  0: drone
```

## 性能优化

### 1. 子图切分策略
系统采用子图切分策略处理8K视频：
- 子图尺寸: 960×1080
- 自动计算切分网格
- 并行处理各子图

### 2. GPU加速
```python
# 启用GPU加速
results = model.predict(source=sub_frames, device=0, verbose=False)
```

### 3. 性能监控
系统提供详细的性能统计：
- 帧读取时间
- 预测时间
- 跟踪时间
- 绘制时间
- 总处理时间

## 输出结果

### 1. 实时显示
- 检测框和跟踪ID
- 目标运动轨迹
- 缩放至1920×1080显示

### 2. 保存结果
- 最后一帧保存为 `output.jpg`
- 性能统计打印到控制台

### 3. 性能报告示例
```
Average Frame Processing Times:
  read_frame: 0.0123s (5.23%)
  predict: 0.1456s (61.87%)
  track: 0.0234s (9.95%)
  draw: 0.0542s (23.05%)
Total: 0.2355s
```

## 常见问题

### Q1: 内存不足怎么办？
A: 可以调整子图尺寸或减少batch size：
```python
sub_width = 640   # 减小子图宽度
sub_height = 720  # 减小子图高度
```

### Q2: 如何提高检测精度？
A: 调整检测阈值和跟踪参数：
```yaml
track_high_thresh: 0.3  # 提高检测阈值
new_track_thresh: 0.3   # 提高新轨迹阈值
```

### Q3: 如何处理不同分辨率的视频？
A: 修改子图切分参数或直接处理：
```python
# 对于较小分辨率，可以不进行切分
if width < 1920 and height < 1080:
    # 直接处理整帧
    results = model.predict(source=[frame], device=0, verbose=False)
```

### Q4: 选择哪个版本的脚本？
A: 根据需求选择：
- **开发调试**: 使用 `uav_tracking_main.py`
- **高性能处理**: 使用 `uav_tracking_threaded.py`
- **快速测试**: 使用 `data/simple_tracking_demo.py`
- **模型评估**: 使用 `model_validation.py`

### Q5: 如何更新数据集路径？
A: 使用路径更新工具：
```bash
python data/update_dataset_paths.py
```

### Q6: 如何处理CUDA内存不足？
A: 可以尝试以下方法：
```python
# 减少batch size
results = model.predict(source=sub_frames, device=0, verbose=False, batch=1)

# 使用CPU处理
results = model.predict(source=sub_frames, device='cpu', verbose=False)

# 减小子图尺寸
sub_width = 640
sub_height = 720
```

### Q7: 如何保存跟踪结果视频？
A: 在脚本中添加视频写入功能：
```python
# 创建视频写入器
fourcc = cv2.VideoWriter_fourcc(*'mp4v')
out = cv2.VideoWriter('output_tracking.mp4', fourcc, fps, (1920, 1080))

# 在处理循环中写入帧
out.write(resized_image)

# 释放写入器
out.release()
```

## 故障排除

### 常见错误及解决方案

1. **ModuleNotFoundError: No module named 'ultralytics'**
   ```bash
pip install ultralytics
```

2. **CUDA out of memory**
   - 减小子图尺寸或使用CPU模式

3. **视频文件无法打开**
   - 检查视频路径是否正确
   - 确保视频格式被OpenCV支持

4. **跟踪效果不佳**
   - 调整跟踪器参数
   - 尝试不同的跟踪算法

### 开发环境设置
```bash
git clone <repository-url>
cd benchmark
pip install -r requirements.txt
```

## 致谢

感谢以下开源项目的贡献：
- [Ultralytics YOLO](https://github.com/ultralytics/ultralytics)
- [ByteTrack](https://github.com/ifzhang/ByteTrack)
- [BoT-SORT](https://github.com/NirAharon/BoT-SORT)


